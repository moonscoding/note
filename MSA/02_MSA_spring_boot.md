\#MSA #springboot



- 나쁜 MSA 징후
  - 책임이 너무 많은 서비스
  - 많은 테이블의 데이터를 관리하는 서비스
  - 과다한 테스트 케이스
  - 한 문제 영역 부분에 속한 MSA가 토끼처럼 번식한다
  - MSA가 지나치게 상호 의존적
  - MSA가 단순한 CRUD(Create Read Update Delete)의 집합



- 서비스 인터페이스
  - REST 철학을 수용
  - URI를 사용해 의도를 저달
  - 요청과 응답에 JSON 사용
  - HTTP 상태코드로 결과를 전달



- MSA를 사용하지 않아야 할때
  - 분산 시스템 구축의 복잡성
  - 가상 서버/컨테이너의 스프롤 (server sprawl)
  - 애플리케이션 유형
  - 데이터 변환과 일관성



- REST 이해
  - 서비스 호출 프로토콜로 HTTP 사용
  - 서비스 행동 양식을 HTTP 표준 동사에 매핑
  - 서비스끼리 교환하는 모든 데이터의 직렬화 형식으로 JSON 사용
  - HTTP 상태 코드를 사용해서 서비스 호출 상태 전달



- MSA + JSON
  - SOAP에 비해 가벼움
  - 가독성 높음
  - 자바스크립트에서 사용하는 기본 직렬화 프로토콜



- 엔드포인트이름
  - 서비스가 제공하는 리소스를 알 수 있는 명확한 URI 이름을 사용
  - 리소스간 관계를 알 수 있는 URI 사용
  - URI 버전체계를 일찍 구축



### #데브옵스

- MSA는 자체 완비형이며 독립적 배포가 가능해야 한다.
  - 단일 소프트웨어 산출물을 사용해 여러 서비스 인스턴스를 시작하거나 제거 할 수 있도록 해야함
- MSA 는 구성가능해야 한다. 
  - 서비스 인스턴스가 시작될 때 구성에 필요한 데이터를 중앙에서 읽어들여 환경변수로 전달된 구성 정보 받음
- MSA 인스턴스는 클라이언트가 위치를 알지 못하게 투명해야 한다.
  - 클라이언트는 서비스의 정확한 위치를 알고 있어서는 안됨 
  - 물리적 위치를 몰라도 애플리케이션이 알 수 있도록 서비스 디스커버리 에이전트와 통신
- MSA는 자신의 상태를 전달해야 한다.
  - 클라우드 아키텍처에서 중요한 부분
  - 인스턴스는 고장날 수 있고 클라이언트는 잘못된 서비스 인스턴스 라우팅을 피해야한다



#### #수명주기

- 서비스 어셈블리
  - 동일한 서비스 코드와 런타임을 정확히 같은 방식으로 배포하기 위해 반복성과 일관성을 보장하는 서비스 패키징과 배포방식
- 서비스 부트스트래핑
  - 사람이 개입하지 않고 모든 환경에 마이크로 서비스 인스턴스를 신속하게 시작하고 배포하기 위해 애플리케이션 환경별 구성 코드를 런타임 코드와 분리하는 방법
- 서비스 등록 및 디스커버리
  - 새로운 MSA 인스턴스가 배포될때 다른 애플리케이션 클라이언트가 발견할 수 있게 만드는 방법
- 서비스 모니터링
  - 마이크로 서비스 환경에서 매우 높은 가용성을 요구하기에 동일 서비스를 여러 인스턴스로 실행함
  - 데스옵스 관점에서 MSA 인스턴스를 모니터링하고 MSA 고장을 회피하는 라우팅과 비정상 서비스 인스턴스를 제거하는지 확인





