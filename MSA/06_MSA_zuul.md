\#MSA #zuul #route #gateway

## 서비스 게이트웨이

- MSA와 같은 분산형 아키텍처에서 여러 서비스 호출 사이에서 발생하는 보안과 로깅, 사용자 추적 등 주요 행위를 확인해야 할 때
- 공통 라이브러리나 프레임워크를 사용해서 서비스마다 이러한 기능을 직접 구축할 수 있다
  - 문제점
    - 구축중인 각 서비스에 이러한 기능을 일관되게 구현이 어려움
    - 이러한 기능을 적절하게 구현하기 어려움
    - 서비스간 복잡한 의존성을 만듬
- 특정 서비스에서 이러한 횡단 관심사들을 추상화하고 독립적인 우치에서 애플리케이션의 모든 MSA 호출에 대한 필터와 라우터 역할을 해야함
- 다음과 같은 횡단 관심사를 `서비스 게이트웨이`라고 합니다.
- 서비스 클라이언트가 서비스를 직접 호출하지 않고 단일한 정책 시행지점 역할을 하는 서비스 게이트웨이로 모든 호출을 경유시켜 최종 목적지로 라우팅



> 중요사항

- 하나의 URI 뒤에 모든 서비스를 배치하고 서비스 디스커버리를 이용해서 모든 호출을 실제 서비스 인스턴스로 매핑
- 서비스 게이트웨이를 경유하는 모든 서비스 호출에 `상관관계 ID`를 삽입
- 호출할 때 생성된 상관관계 ID를 HTTP 응답에 삽입하고 클라이언트에 회신
- 대중이 사용중인 것과 다른 조직 서비스 인스턴스 엔드포인트로 라우팅하는 동적 라이팅 매커니즘을 구축



### #서비스게이트웨이

- 서비스 클라이언트가 서비스를 직접 호출한다면 
  각 서비스에서 보안이나 로깅 같은 횡단 관심사 로직을 직접 구현하는 것 외에 쉽게 구현할 수 있는 다른 방법은 없음
- 서비스 게이트웨이는 서비스 클라이언트와 호출될 서비스 사이에서 중개 역할
- 서비스 클라이언트는 서비스 게이트웨이가 관리하는 하나의 URI를 통해 통신
- 서비스 게이트웨이는 서비스 클라이언트 호출에서 보낸 경로를 추려 내고 서비스 클라이언트가 호출하려는 서비스를 판별
- 서비스 게이트웨이는 클라이언트가 각 서비스에 보내는 모든 호출사이에 위치하므로 게이트웨이는 각 서비스 호출에 대한 `중앙 집중식 정책 시행 지점(PEP)`역할을 한다
  - 각 개발팀이 이러한 관심사를 구현하지 않아도 서비스의 횡단 관심사를 단일 지점에서 구현할 수 있다는 것을 의미
  - `정적라우팅`
    - 서비스 게이트웨이는 단일 서비스 URI와 API 경로로 모든 서비스를 호출
    - 개발자는 모든 서비스에 대해 하나의 서비스 엔드포인드만 알면됨
  - `동적라우팅`
    - 서비스 게이트웨이는 유입되는 서비스 요청을 조사하고 요청 데이터를 기반으로 서비스 호출자 대상에 따라 지능형 라우팅 수행 가능
    - 베타 프로그램에 참여하는 고객의 서비스 호출은 모두 다른 코드 버전이 수행되는 특정 서비스 클러스터로 라우팅
  - `인증과 인가`
    - 모든 서비스 호출은 서비스 게이트웨이로 라우팅 되므로 서비스 게이트웨이는 서비스 호출자가 자신을 인증하고 서비슬를 호출할 권한 여부를 확인할 수 있는 최적 장소
  - `측정 지표 수집과 로깅`
    - 서비스 게이트웨이를 사용합면 서비스 호출이 서비스 게이트웨이를 통과할 때 측정 지표와 로그 정보를 수집할 수 있음 
    - 규격화된 로깅을 보장하기 위해서 사용자 요청에서 주요 정보가 누락되지 않았는지 확인하는데 사용

> 서비스 게이트웨이가 단일 장애나 잠재적 병목 지점의 위험은 없는가 ?

- 집중화된 로드 밸런서는 단일 장애 지점과 서비스의 병목점이 될 가능성이 있음

- 서비스 게이트웨이를 올바르게 구현하지 않으면 동일한 위험 부담을 가짐

- 서비스 게이트웨이를 구현할 때 다음 두가지를 염두

  - 로드 밸런서는 각 서비스 그룹 앞에 있을 때 여전히 유용
    - 여러 서비스 게이트웨이 인스턴스 앞에 로드 밸런서를 두는 것은 적절한 설계
    - 서비스 게이트웨이를 확장할 수 있음
    - 모든 서비스 인스턴스 앞에 로드 밸런서를 두는 것이 병목점이 될 수 있어 좋은 방법은 아님
  - 작성하는 서비스 게이트웨이 코드를 무상태로 유지
    - 서비스 게이트웨이 정보를 메모리에 저장하지 말아야 함
    - 주의하지 않으면 게이트웨이의 확장성을 제한하고 모든 서비스 게이트웨이 인스턴스에 데이터가 복제되도록 해야함
  - 작성하는 서비스 게이트웨이 코드를 가볍게 유지
    - 서비스 게이트웨이는 서비스 호출에 대한 병목점
    - 여러 DB 호출이 포함된 복잡한 코드는 서비스 게이트웨이에서 추적하기 힘든 성능 문제의 원인

  

  

## 넷플릭스 주울

- 주울(Zuul)은 스프링 클라우드 애너테이션으로 설정
  - 애플리케이션의 모든 서비스 경로를 단일 URI로 매핑
    - 주울의 매핑이 단일 URI로 제한 되는 것은 아님
    - 주울에서는 여러 경로 항목을 정의해서 경로 매핑을 매우 세분화 가능
    - 주울의 가장 일반적인 사용 사례는 모든 서비스 호출이 통과하는 단일 진입점을 구축하는 것
  - 게이트웨이로 유입되는 요청을 검사하고 대응할 수 있는 필터 작성
    - 필터를 사용하면 코드에 정책 시행 지점을 주입해서 모든 서비스 호출에 광범위한 작업을 일관된 방식으로 수행가능



> 시작전 3가지

- 주울 스프링 부트 프로젝트를 설정하고 메이븐 의존성 적절히 구성
- 스프링 부트 프로젝트를 주울 서비스로 설정하도록 스프링 클라우드 애너테이션으로 수정
- 주울을 유레카와 통신하도록 구성



>  pom.xml

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
</dependency>
```

> ZuulServerApplication.java

```java
@SpringBootApplication
@EnableZuulProxy // 서비스를 주울 서버로 사용
public class ZuulServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ZuulServerApplication.class, args);
    }
}
```





### #주울_유레카

- 주울 프록시 서비는 기본적으로 스프링 제품과 동작하도록 설계
- 주울을 자동으로 유레카를 사용해서 서비스 ID로 서비스를 찾은 후 넥플릭스 리본으로 주울 내부에서 요청에 대한 클라이언트 측 부하 분산을 수행

> application.yml

```yaml
eureka:
  instance:
    preferIpAddress: true
  client:
    registerWithEureka: true
    fetchRegistry: true
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
```

### #주울_경로구성

- 주을은 본래 리버스 프록시 
- 리버스 프록시는 자원에 접근하려는 클라이언트와 자원 사이에 위치한 중개 서버
- 클라이언트는 프록시가 아닌 다른 서버와 통신하는 것 조차 알 수 없고, 리버스 프록시는 클라이언트의 요청을 받아 클라이언트를 대신해 원격 자원 호출
- 마이크로서비스 아키택처에서 주울(리버스프록시)은 클라이언트에서 받은 마이크로서비스 호출을 하위 서비스에 전달
- 서비스 클라이언트는 주울과 통신한다고 생각
- 주울이 하위 클라이언트와 통신하려면 유입되는 호출을 어떻게 하위 경로로 매핑할지 알아야

> 주울 매커니즘

- 서비스 디스커버리를 이용한 자동 경로 매핑
- 서비스 디스커버리를 이용한 수도 경로 매핑
- 정적 URI을 이용한 수동 경로 매핑



#### #서비스디스커버리_자동경로매핑

- application.yml 에 경로를 정의해서 모든 경로를 매핑
- 특별한 구성 없이도 서비스 ID를 기반으로 요청을 자동 라우팅
- 경로를 지정하지 않으면 호출되는 서비스의 유레카 서비스 ID를 사용해서 하위 서비스 인스턴스에 매핑
  - organizationservice (조직 서비스) 를 호출하고 주울로 자동화된 라우팅을 사용하고자 하면
  - 클라이언트가 다음 URI 엔트포인트로 주울 서비스 인스턴스를 호출하면된다
  - http://localhost:5555/organizationservice/vi/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a
-  주울서버관리경로 `/routes`
  - http://localhost:5555/actuator/routes 



#### #서비스디스커버리_수동경로매핑

- 주울 사용시 서비스의 유레카 서비스 ID로 자동 생성된 경로에 의존하지 않고 명시적으로 매핑 경로를 정의할 수 있어 더욱 세분화 가능
- 주울에서 조직 서비스의 기본 경로를 수정
  - `/organizationservice/v1/organizations/{organization-id}`
- 자동경로매핑이 없어지는 것은 아님, 그대로 존재

> application.yml

```yaml
zuul:
  ignored-service: 'organizationservice' # 자동경로매핑 유지
  # ignored-services: 'organizationservice' # 자동경로매핑 제외
  # ignored-services: '*' # 자동경로매핑 모두제외
  routes:
    organizationservice: /organization/**
```

-  주울은 유레카 서비스 ID 기반으로 서비스를 제공하는 자동 경로 매핑만 사용시에 실행 중인 서비스 인스턴스가 없으면 서비스 경로를 노출하지 않음
- 수동으로 서비스 디스커버리 ID 경로를 매핑한다면 유레카에 등록된 서비스 인스턴스가 없어도 주울은 그 경로를 계속 표시
- 존재하지 않는 서비스 경로를 호출하면 주울은 500에러 반환



> application.yml

- http://localhost:5555/api/organization/v1/organizations/

```yaml
zuul:
  ignored-services: '*' # 자동경로매핑 모두제외
  prefix: /api
  routes:
    organizationservice: /organization/**
    licensingservice: /licensing/**
```



#### #정적URI_수동경로매핑

- 유레카로 관리하지 않는 서비스를 라우팅하는데도 주울을 사용할 수 있음
- 주울은 고정 URI에 직접 라우팅하도록 설정이 가능

> application.yml

```yaml 
zuul:
  routes:
    licensestatic: # 주울은 키 이름으로 서비스를 식별
    	path: /licensestatic/** # 라이선싱 서비스에 대한 정적 경로
    	url: http://licenseservice-static:8081 # 유레카를 통하지 않고 주울이 직접 호출할 라이선싱 서비스의 정적 인스턴스를 설정
```



- 리본을 유레카와 통합하지 않고 부하 분산할 대상이 될 서비스 인스턴스를 추가하도록 중울 구성

```yaml 
zuul:
  routes:
    licensestatic: 
    	path: licensestatic/**
    	serviceId: licensestatic # 리본에서 서비스를 찾는데 사용하는 서비스 ID 정의
ribbon:
	eureka:
		enabled: false # 리본에서 유레카 지원을 끈다
	licensestatic:
		ribbon:
			listOfServers: http://licenseservice-static1:8801 , 
			http://licenseservice-static2:8802 # 요청을 라우팅하는데 사용된 서버 목록 
```



#### #경로구성_동적로딩

- 경로를 동적으로 재로딩하면 주울 서버를 재활용하지 않고도 경로 매핑을 변경할 수 있어  유용
- 기존 경로를 신속하게 수정하고 새로운 경로를 추가하면 환경 내 각 주울 서버를 재활용해야함
  - 

